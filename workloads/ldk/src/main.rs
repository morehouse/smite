//! Minimal ldk-node wrapper for smite fuzzing.
//!
//! Uses bitcoind RPC as the backend, prints the node's pubkey on startup, and
//! waits for SIGTERM to shut down cleanly. Ignores all events generated by
//! ldk-node since we reset the VM after each fuzz iteration anyway.

use std::net::SocketAddr;
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::Duration;

use ldk_node::Builder;
use ldk_node::bitcoin::Network;

/// Signal handler sets this to true to trigger shutdown.
static SHUTDOWN: AtomicBool = AtomicBool::new(false);

extern "C" fn handle_signal(_: libc::c_int) {
    SHUTDOWN.store(true, Ordering::SeqCst);
}

fn main() {
    // Set up signal handlers for graceful shutdown
    unsafe {
        // Cast through pointer to satisfy Rust's function-to-integer cast rules
        let sighandler = handle_signal as *const () as libc::sighandler_t;
        libc::signal(libc::SIGTERM, sighandler);
        libc::signal(libc::SIGINT, sighandler);
    }

    let args: Vec<String> = std::env::args().collect();
    if args.len() != 4 {
        eprintln!(
            "Usage: {} <data-dir> <listen-port> <bitcoind-rpc-port>",
            args[0]
        );
        std::process::exit(1);
    }

    let data_dir = args[1].clone();
    let listen_port: u16 = args[2].parse().expect("valid listen port");
    let rpc_port: u16 = args[3].parse().expect("valid RPC port");

    let listen_addr: SocketAddr = format!("0.0.0.0:{listen_port}")
        .parse()
        .expect("valid listen address");

    let node = Builder::new()
        .set_network(Network::Regtest)
        .set_chain_source_bitcoind_rpc(
            "127.0.0.1".to_string(),
            rpc_port,
            "rpcuser".to_string(),
            "rpcpass".to_string(),
        )
        .set_listening_addresses(vec![listen_addr.into()])
        .expect("valid listening addresses")
        .set_storage_dir_path(data_dir)
        .build()
        .expect("node build");

    node.start().expect("node start");

    // Output for LdkTarget to parse
    println!("PUBKEY:{}", node.node_id());
    println!("READY");

    // Wait for shutdown signal
    while !SHUTDOWN.load(Ordering::SeqCst) {
        std::thread::sleep(Duration::from_millis(100));
    }

    node.stop().expect("node stop");
}
